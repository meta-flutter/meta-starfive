From b570feee24c2c390e5c69f35eaf62e81658b1ac1 Mon Sep 17 00:00:00 2001
From: Kito Cheng <kito.cheng@sifive.com>
Date: Fri, 20 Nov 2020 15:52:53 +0800
Subject: [PATCH 32/60] Add TARGET_COMPUTE_MULTILIB hook to override multi-lib
 result.

Create a new hook to let target could override the multi-lib result,
the motivation is RISC-V might have very complicated multi-lib re-use
rule*, which is hard to maintain and use current multi-lib scripts,
we even hit the "argument list too long" error when we tried to add more
multi-lib reuse rule.

So I think it would be great to have a target specific way to determine
the multi-lib re-use rule, then we could write those rule in C, instead
of expand every possible case in MULTILIB_REUSE.

* Here is an example for RISC-V multi-lib rules:
https://gist.github.com/kito-cheng/0289cd42d9a756382e5afeb77b42b73b

gcc/ChangeLog:

	* common/common-target.def (compute_multilib): New.
	* common/common-targhooks.c (default_compute_multilib): New.
	* doc/tm.texi.in (TARGET_COMPUTE_MULTILIB): New.
	* doc/tm.texi: Regen.
	* gcc.c: Include common/common-target.h.
	(set_multilib_dir) Call targetm_common.compute_multilib.
	(SWITCH_LIVE): Move to opts.h.
	(SWITCH_FALSE): Ditto.
	(SWITCH_IGNORE): Ditto.
	(SWITCH_IGNORE_PERMANENTLY): Ditto.
	(SWITCH_KEEP_FOR_GCC): Ditto.
	(struct switchstr): Ditto.
	* opts.h (SWITCH_LIVE): Move from gcc.c.
	(SWITCH_FALSE): Ditto.
	(SWITCH_IGNORE): Ditto.
	(SWITCH_IGNORE_PERMANENTLY): Ditto.
	(SWITCH_KEEP_FOR_GCC): Ditto.
	(struct switchstr): Ditto.
---
 gcc/common/common-target.def  | 25 ++++++++++++++++++
 gcc/common/common-targhooks.c | 15 +++++++++++
 gcc/doc/tm.texi               |  5 ++++
 gcc/doc/tm.texi.in            |  3 +++
 gcc/gcc.c                     | 48 +++++++++--------------------------
 gcc/opts.h                    | 36 ++++++++++++++++++++++++++
 6 files changed, 96 insertions(+), 36 deletions(-)

diff --git a/gcc/common/common-target.def b/gcc/common/common-target.def
index 2f64ebe55de..296de01177d 100644
--- a/gcc/common/common-target.def
+++ b/gcc/common/common-target.def
@@ -84,6 +84,31 @@ DEFHOOK
  vec<const char *>, (int option_code, const char *prefix),
  default_get_valid_option_values)
 
+DEFHOOK
+(compute_multilib,
+ "Some target like RISC-V might have complicated multilib reuse rule which is\
+  hard to implemented on current multilib scheme, this hook allow target to\
+  override the result from built-in multilib mechanism.\
+  @var{switches} is the raw option list with @var{n_switches} items;\
+  @var{multilib_dir} is the multi-lib result which compute by the built-in\
+  multi-lib mechanism;\
+  @var{multilib_defaults} is the default options list for multi-lib; \
+  @var{multilib_select} is the string contain the list of supported multi-lib, \
+  and the option checking list. \
+  @var{multilib_matches}, @var{multilib_exclusions}, and @var{multilib_reuse} \
+  are corresponding to @var{MULTILIB_MATCHES}, @var{MULTILIB_EXCLUSIONS} \
+  @var{MULTILIB_REUSE}. \
+  The default definition does nothing but return @var{multilib_dir} directly.",
+ const char *, (const struct switchstr *switches,
+		int n_switches,
+		const char *multilib_dir,
+		const char *multilib_defaults,
+		const char *multilib_select,
+		const char *multilib_matches,
+		const char *multilib_exclusions,
+		const char *multilib_reuse),
+ default_compute_multilib)
+
 /* Leave the boolean fields at the end.  */
 
 /* True if unwinding tables should be generated by default.  */
diff --git a/gcc/common/common-targhooks.c b/gcc/common/common-targhooks.c
index 554ed36c3d2..16a1a35e141 100644
--- a/gcc/common/common-targhooks.c
+++ b/gcc/common/common-targhooks.c
@@ -90,3 +90,18 @@ const struct default_options empty_optimization_table[] =
   {
     { OPT_LEVELS_NONE, 0, NULL, 0 }
   };
+
+/* Default version of TARGET_COMPUTE_MULTILIB.  */
+const char *
+default_compute_multilib(
+  const struct switchstr *,
+  int,
+  const char *multilib,
+  const char *,
+  const char *,
+  const char *,
+  const char *,
+  const char *)
+{
+  return multilib;
+}
diff --git a/gcc/doc/tm.texi b/gcc/doc/tm.texi
index ae14d07a202..f416ab43287 100644
--- a/gcc/doc/tm.texi
+++ b/gcc/doc/tm.texi
@@ -758,6 +758,11 @@ options are changed via @code{#pragma GCC optimize} or by using the
 Set target-dependent initial values of fields in @var{opts}.
 @end deftypefn
 
+@deftypefn {Common Target Hook} {const char *} TARGET_COMPUTE_MULTILIB (const struct switchstr *@var{switches}, int @var{n_switches}, const char *@var{multilib_dir}, const char *@var{multilib_defaults}, const char *@var{multilib_select}, const char *@var{multilib_matches}, const char *@var{multilib_exclusions}, const char *@var{multilib_reuse})
+Some target like RISC-V might have complicated multilib reuse rule which is  hard to implemented on current multilib scheme, this hook allow target to  override the result from built-in multilib mechanism.  @var{switches} is the raw option list with @var{n_switches} items;  @var{multilib_dir} is the multi-lib result which compute by the built-in  multi-lib mechanism;  @var{multilib_defaults} is the default options list for multi-lib;   @var{multilib_select} is the string contain the list of supported multi-lib,   and the option checking list.   @var{multilib_matches}, @var{multilib_exclusions}, and @var{multilib_reuse}   are corresponding to @var{MULTILIB_MATCHES}, @var{MULTILIB_EXCLUSIONS}   @var{MULTILIB_REUSE}.   The default definition does nothing but return @var{multilib_dir} directly.
+@end deftypefn
+
+
 @defmac SWITCHABLE_TARGET
 Some targets need to switch between substantially different subtargets
 during compilation.  For example, the MIPS target has one subtarget for
diff --git a/gcc/doc/tm.texi.in b/gcc/doc/tm.texi.in
index 3be984bbd5c..27c2320ac65 100644
--- a/gcc/doc/tm.texi.in
+++ b/gcc/doc/tm.texi.in
@@ -736,6 +736,9 @@ options are changed via @code{#pragma GCC optimize} or by using the
 
 @hook TARGET_OPTION_INIT_STRUCT
 
+@hook TARGET_COMPUTE_MULTILIB
+
+
 @defmac SWITCHABLE_TARGET
 Some targets need to switch between substantially different subtargets
 during compilation.  For example, the MIPS target has one subtarget for
diff --git a/gcc/gcc.c b/gcc/gcc.c
index 5ecd8fbf031..2d9c1317734 100644
--- a/gcc/gcc.c
+++ b/gcc/gcc.c
@@ -43,6 +43,7 @@ compilation is specified by a string called a "spec".  */
 #include "opts.h"
 #include "filenames.h"
 #include "spellcheck.h"
+#include "common/common-target.h"
 
 
 
@@ -3370,42 +3371,6 @@ execute (void)
   }
 }
 
-/* Find all the switches given to us
-   and make a vector describing them.
-   The elements of the vector are strings, one per switch given.
-   If a switch uses following arguments, then the `part1' field
-   is the switch itself and the `args' field
-   is a null-terminated vector containing the following arguments.
-   Bits in the `live_cond' field are:
-   SWITCH_LIVE to indicate this switch is true in a conditional spec.
-   SWITCH_FALSE to indicate this switch is overridden by a later switch.
-   SWITCH_IGNORE to indicate this switch should be ignored (used in %<S).
-   SWITCH_IGNORE_PERMANENTLY to indicate this switch should be ignored.
-   SWITCH_KEEP_FOR_GCC to indicate that this switch, otherwise ignored,
-   should be included in COLLECT_GCC_OPTIONS.
-   in all do_spec calls afterwards.  Used for %<S from self specs.
-   The `known' field describes whether this is an internal switch.
-   The `validated' field describes whether any spec has looked at this switch;
-   if it remains false at the end of the run, the switch must be meaningless.
-   The `ordering' field is used to temporarily mark switches that have to be
-   kept in a specific order.  */
-
-#define SWITCH_LIVE    			(1 << 0)
-#define SWITCH_FALSE   			(1 << 1)
-#define SWITCH_IGNORE			(1 << 2)
-#define SWITCH_IGNORE_PERMANENTLY	(1 << 3)
-#define SWITCH_KEEP_FOR_GCC		(1 << 4)
-
-struct switchstr
-{
-  const char *part1;
-  const char **args;
-  unsigned int live_cond;
-  bool known;
-  bool validated;
-  bool ordering;
-};
-
 static struct switchstr *switches;
 
 static int n_switches;
@@ -9083,6 +9048,17 @@ set_multilib_dir (void)
       ++p;
     }
 
+  multilib_dir =
+    targetm_common.compute_multilib (
+      switches,
+      n_switches,
+      multilib_dir,
+      multilib_defaults,
+      multilib_select,
+      multilib_matches,
+      multilib_exclusions,
+      multilib_reuse);
+
   if (multilib_dir == NULL && multilib_os_dir != NULL
       && strcmp (multilib_os_dir, ".") == 0)
     {
diff --git a/gcc/opts.h b/gcc/opts.h
index 8f594b46e33..0a8b8e9d2d9 100644
--- a/gcc/opts.h
+++ b/gcc/opts.h
@@ -475,4 +475,40 @@ extern void prepend_xassembler_to_collect_as_options (const char *, obstack *);
   } \
   while (false)
 
+/* Find all the switches given to us
+   and make a vector describing them.
+   The elements of the vector are strings, one per switch given.
+   If a switch uses following arguments, then the `part1' field
+   is the switch itself and the `args' field
+   is a null-terminated vector containing the following arguments.
+   Bits in the `live_cond' field are:
+   SWITCH_LIVE to indicate this switch is true in a conditional spec.
+   SWITCH_FALSE to indicate this switch is overridden by a later switch.
+   SWITCH_IGNORE to indicate this switch should be ignored (used in %<S).
+   SWITCH_IGNORE_PERMANENTLY to indicate this switch should be ignored.
+   SWITCH_KEEP_FOR_GCC to indicate that this switch, otherwise ignored,
+   should be included in COLLECT_GCC_OPTIONS.
+   in all do_spec calls afterwards.  Used for %<S from self specs.
+   The `known' field describes whether this is an internal switch.
+   The `validated' field describes whether any spec has looked at this switch;
+   if it remains false at the end of the run, the switch must be meaningless.
+   The `ordering' field is used to temporarily mark switches that have to be
+   kept in a specific order.  */
+
+#define SWITCH_LIVE    			(1 << 0)
+#define SWITCH_FALSE   			(1 << 1)
+#define SWITCH_IGNORE			(1 << 2)
+#define SWITCH_IGNORE_PERMANENTLY	(1 << 3)
+#define SWITCH_KEEP_FOR_GCC		(1 << 4)
+
+struct switchstr
+{
+  const char *part1;
+  const char **args;
+  unsigned int live_cond;
+  bool known;
+  bool validated;
+  bool ordering;
+};
+
 #endif
-- 
2.25.1

