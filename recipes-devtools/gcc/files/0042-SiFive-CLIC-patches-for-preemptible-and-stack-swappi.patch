From 0213fca03c58c373050a46afa64f2734896306e7 Mon Sep 17 00:00:00 2001
From: Jim Wilson <jimw@sifive.com>
Date: Thu, 21 Feb 2019 19:50:46 -0800
Subject: [PATCH 42/60] SiFive CLIC patches, for preemptible and stack-swapping
 interrupt support.

---
 gcc/config/riscv/constraints.md               |   5 +
 gcc/config/riscv/predicates.md                |   4 +
 gcc/config/riscv/riscv.c                      | 232 +++++++++++++++---
 gcc/config/riscv/riscv.md                     |  56 +++++
 gcc/doc/extend.texi                           |  25 ++
 gcc/doc/md.texi                               |   3 +
 gcc/testsuite/gcc.target/riscv/interrupt-5.c  |  15 ++
 .../riscv/interrupt-conflict-mode.c           |   2 +-
 .../gcc.target/riscv/preemptible-1.c          |  11 +
 .../gcc.target/riscv/preemptible-2.c          |  11 +
 .../gcc.target/riscv/preemptible-3.c          |   9 +
 gcc/testsuite/gcc.target/riscv/stack-swap-1.c |  17 ++
 12 files changed, 352 insertions(+), 38 deletions(-)
 create mode 100644 gcc/testsuite/gcc.target/riscv/preemptible-1.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/preemptible-2.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/preemptible-3.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/stack-swap-1.c

diff --git a/gcc/config/riscv/constraints.md b/gcc/config/riscv/constraints.md
index bf98f566b36..40cf8884afb 100644
--- a/gcc/config/riscv/constraints.md
+++ b/gcc/config/riscv/constraints.md
@@ -162,3 +162,8 @@
   "POLY_INT"
   (and (match_code "const_poly_int")
        (match_test "CONST_POLY_INT_COEFFS (op)[0] == UNITS_PER_V_REG.coeffs[0]")))
+
+(define_constraint "C"
+  "A 12-bit unsigned immediate for CSR address."
+  (and (match_code "const_int")
+       (match_test "IN_RANGE (ival, 0, IMM_REACH-1)")))
diff --git a/gcc/config/riscv/predicates.md b/gcc/config/riscv/predicates.md
index d3b8e756fdb..c94e1cb5a71 100644
--- a/gcc/config/riscv/predicates.md
+++ b/gcc/config/riscv/predicates.md
@@ -43,6 +43,10 @@
   (ior (match_operand 0 "const_csr_operand")
        (match_operand 0 "register_operand")))
 
+(define_predicate "csr_address"
+  (and (match_code "const_int")
+       (match_test "IN_RANGE (INTVAL (op), 0, IMM_REACH-1)")))
+
 (define_predicate "sle_operand"
   (and (match_code "const_int")
        (match_test "SMALL_OPERAND (INTVAL (op) + 1)")))
diff --git a/gcc/config/riscv/riscv.c b/gcc/config/riscv/riscv.c
index abf5c445d09..c6a756a76ce 100644
--- a/gcc/config/riscv/riscv.c
+++ b/gcc/config/riscv/riscv.c
@@ -102,7 +102,7 @@ enum riscv_address_type {
 };
 
 /* Information about a function's frame layout.  */
-struct GTY(())  riscv_frame_info {
+struct GTY(()) riscv_frame_info {
   /* The size of the frame in bytes.  */
   poly_int64 total_size;
 
@@ -135,7 +135,18 @@ enum riscv_privilege_levels {
   UNKNOWN_MODE, USER_MODE, SUPERVISOR_MODE, MACHINE_MODE
 };
 
-struct GTY(())  machine_function {
+struct GTY(()) riscv_interrupt_flags {
+  /* For an interrupt handler, indicates the privilege level.  */
+  enum riscv_privilege_levels interrupt_mode : 2;
+  /* True if current function is an SiFive CLIC preemptible interrupt
+     function.  */
+  bool sifive_clic_preemptible_p : 1;
+  /* True if current function is an SiFive CLIC stack swap interrupt
+     function.  */
+  bool sifive_clic_stack_swap_p : 1;
+};
+
+struct GTY(()) machine_function {
   /* The number of extra stack bytes taken up by register varargs.
      This area is allocated by the callee at the very top of the frame.  */
   int varargs_size;
@@ -145,8 +156,8 @@ struct GTY(())  machine_function {
 
   /* True if current function is an interrupt function.  */
   bool interrupt_handler_p;
-  /* For an interrupt handler, indicates the privilege level.  */
-  enum riscv_privilege_levels interrupt_mode;
+  /* For an interrupt handler, hold various argument flag bits.  */
+  struct riscv_interrupt_flags interrupt_flags;
 
   /* True if attributes on current function have been checked.  */
   bool attributes_checked_p;
@@ -352,7 +363,7 @@ static const struct attribute_spec riscv_attribute_table[] =
   { "naked",	0,  0, true, false, false, false,
     riscv_handle_fndecl_attribute, NULL },
   /* This attribute generates prologue/epilogue for interrupt handlers.  */
-  { "interrupt", 0, 1, false, true, true, false,
+  { "interrupt", 0, 2, false, true, true, false,
     riscv_handle_type_attribute, NULL },
 
   /* The last attribute spec is set to be NULL.  */
@@ -3246,7 +3257,7 @@ riscv_handle_type_attribute (tree *node ATTRIBUTE_UNUSED, tree name, tree args,
   /* Check for an argument.  */
   if (is_attribute_p ("interrupt", name))
     {
-      if (args)
+      while (args != NULL)
 	{
 	  tree cst = TREE_VALUE (args);
 	  const char *string;
@@ -3262,14 +3273,18 @@ riscv_handle_type_attribute (tree *node ATTRIBUTE_UNUSED, tree name, tree args,
 
 	  string = TREE_STRING_POINTER (cst);
 	  if (strcmp (string, "user") && strcmp (string, "supervisor")
-	      && strcmp (string, "machine"))
+	      && strcmp (string, "machine")
+	      && strcmp (string, "SiFive-CLIC-preemptible")
+	      && strcmp (string, "SiFive-CLIC-stack-swap"))
 	    {
 	      warning (OPT_Wattributes,
-		       "argument to %qE attribute is not \"user\", \"supervisor\", or \"machine\"",
-		       name);
+		       "unrecognized argument to %qE attribute", name);
 	      *no_add_attrs = true;
 	    }
+	  args = TREE_CHAIN (args);
 	}
+
+      return NULL_TREE;
     }
 
   return NULL_TREE;
@@ -3581,6 +3596,7 @@ riscv_memmodel_needs_release_fence (enum memmodel model)
    'A'	Print the atomic operation suffix for memory model OP.
    'F'	Print a FENCE if the memory model requires a release.
    'z'	Print x0 if OP is zero, otherwise print OP normally.
+   'x'	Print CONST_INT OP as a CSR register name or as a hex number.
    'i'	Print i if the operand is not a register.
    'v'  Print the sole immediate value of a const vec duplicate.
    'V'  Print the negated sole immediate value of a const vec duplicate.
@@ -3708,6 +3724,32 @@ riscv_print_operand (FILE *file, rtx op, int letter)
 	default:
 	  if (letter == 'z' && op == CONST0_RTX (GET_MODE (op)))
 	    fputs (reg_names[GP_REG_FIRST], file);
+	  else if (letter == 'x' && GET_CODE (op) == CONST_INT)
+	    {
+	      unsigned HOST_WIDE_INT reg_num = UINTVAL (op);
+	      const char *reg_name = NULL;
+
+	      switch (reg_num)
+		{
+		case MSTATUS_REGNUM:
+		  reg_name = "mstatus";
+		  break;
+		case MEPC_REGNUM:
+		  reg_name = "mepc";
+		  break;
+		case MCAUSE_REGNUM:
+		  reg_name = "mcause";
+		  break;
+		case MSCRATCHCSW_REGNUM:
+		  reg_name = "mscratchcsw";
+		  break;
+		}
+	      
+	      if (reg_name)
+		asm_fprintf (file, "%s", reg_name);
+	      else
+		asm_fprintf (file, "0x%wx", reg_num);
+	    }
 	  else if (letter && letter != 'z')
 	    output_operand_lossage ("invalid use of '%%%c'", letter);
 	  else
@@ -4062,8 +4104,14 @@ riscv_compute_frame_info (void)
       unsigned x_save_size = riscv_stack_align (num_x_saved * UNITS_PER_WORD);
       unsigned num_save_restore = 1 + riscv_save_libcall_count (frame->mask);
 
+      /* In an SiFive CLIC preemptible interrupt function, we need extra space
+	 for the initial saves of S0 and S1.  */
+      if (cfun->machine->interrupt_flags.sifive_clic_preemptible_p)
+	x_save_size = RISCV_STACK_ALIGN ((num_x_saved + 2) * UNITS_PER_WORD);
+
       /* Only use save/restore routines if they don't alter the stack size.  */
-      if (riscv_stack_align (num_save_restore * UNITS_PER_WORD) == x_save_size)
+      else if (riscv_stack_align (num_save_restore * UNITS_PER_WORD)
+	       == x_save_size)
 	{
 	  /* Libcall saves/restores 3 registers at once, so we need to
 	     allocate 12 bytes for callee-saved register.  */
@@ -4446,6 +4494,7 @@ riscv_expand_prologue (void)
 {
   struct riscv_frame_info *frame = &cfun->machine->frame;
   poly_int64 size = frame->total_size;
+  HOST_WIDE_INT interrupt_size = 0;
   unsigned mask = frame->mask;
   rtx insn;
 
@@ -4469,6 +4518,12 @@ riscv_expand_prologue (void)
       REG_NOTES (insn) = dwarf;
     }
 
+  /* Swap in the stack pointer from the mscratch register.  */
+  if (cfun->machine->interrupt_flags.sifive_clic_stack_swap_p)
+    emit_insn (gen_riscv_csr_read_write (stack_pointer_rtx,
+					 GEN_INT (MSCRATCHCSW_REGNUM),
+					 stack_pointer_rtx));
+
   /* Save the registers.  */
   if ((frame->mask | frame->fmask) != 0)
     {
@@ -4484,7 +4539,33 @@ riscv_expand_prologue (void)
 			    GEN_INT (-step1));
       RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;
 
-      riscv_for_each_saved_reg (size, riscv_save_reg, false, false);
+      if (cfun->machine->interrupt_flags.sifive_clic_preemptible_p)
+	{
+	  /* Save S0 and S1.  */
+	  riscv_save_restore_reg (word_mode, S0_REGNUM,
+				  step1 - (1 * UNITS_PER_WORD),
+				  riscv_save_reg);
+	  riscv_save_restore_reg (word_mode, S1_REGNUM,
+				  step1 - (2 * UNITS_PER_WORD),
+				  riscv_save_reg);
+	  /* Account for the stack size used by interrupt register saving.  */
+	  interrupt_size = 2 * UNITS_PER_WORD;
+
+	  /* Load cause into s0.  */
+	  emit_insn (gen_riscv_csr_read (gen_rtx_REG (word_mode, S0_REGNUM),
+					 GEN_INT (MCAUSE_REGNUM)));
+	  /* Load epc into s1.  */
+	  emit_insn (gen_riscv_csr_read (gen_rtx_REG (word_mode, S1_REGNUM),
+					 GEN_INT (MEPC_REGNUM)));
+	  /* Re-enable interrupts.  */
+	  emit_insn (gen_riscv_csr_read_set_bits (gen_rtx_REG (word_mode,
+							       GP_REG_FIRST),
+						  GEN_INT (MSTATUS_REGNUM),
+						  GEN_INT (MSTATUS_MIE_BIT)));
+	}
+
+      riscv_for_each_saved_reg (size + interrupt_size, riscv_save_reg,
+				false, false);
     }
 
   frame->mask = mask; /* Undo the above fib.  */
@@ -4492,6 +4573,10 @@ riscv_expand_prologue (void)
   /* Set up the frame pointer, if we're using one.  */
   if (frame_pointer_needed)
     {
+      if (cfun->machine->interrupt_flags.sifive_clic_preemptible_p)
+	error ("SiFive CLIC preemptible %qs function cannot use a frame pointer",
+	       "interrupt");
+
       poly_int64 offset = frame->hard_frame_pointer_offset - size;
       insn = gen_add3_insn (hard_frame_pointer_rtx, stack_pointer_rtx,
 			    GEN_INT (offset.to_constant ()));
@@ -4576,6 +4661,7 @@ riscv_expand_epilogue (int style)
   unsigned mask = frame->mask;
   poly_int64 step1 = frame->total_size;
   HOST_WIDE_INT step2 = 0;
+  HOST_WIDE_INT interrupt_size = 0;
   bool use_restore_libcall = ((style == NORMAL_RETURN)
 			      && riscv_use_save_libcall (frame));
   rtx ra = gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM);
@@ -4701,10 +4787,13 @@ riscv_expand_epilogue (int style)
 
   if (use_restore_libcall)
     frame->mask = 0; /* Temporarily fib that we need not save GPRs.  */
+  else if (cfun->machine->interrupt_flags.sifive_clic_preemptible_p)
+    interrupt_size = 2 * UNITS_PER_WORD;
 
   /* Restore the registers.  */
-  riscv_for_each_saved_reg (frame->total_size - step2, riscv_restore_reg,
-			    true, style == EXCEPTION_RETURN);
+  riscv_for_each_saved_reg (frame->total_size - step2 + interrupt_size,
+			    riscv_restore_reg, true,
+			    style == EXCEPTION_RETURN);
 
   if (use_restore_libcall)
     {
@@ -4712,6 +4801,29 @@ riscv_expand_epilogue (int style)
       gcc_assert (step2 >= frame->save_libcall_adjustment);
       step2 -= frame->save_libcall_adjustment;
     }
+  else if (cfun->machine->interrupt_flags.sifive_clic_preemptible_p
+	   && (frame->mask | frame->fmask) != 0)
+    {
+      /* Disable interrupts.  */
+      emit_insn (gen_riscv_csr_read_clear_bits (gen_rtx_REG (word_mode,
+							     GP_REG_FIRST),
+						GEN_INT (MSTATUS_REGNUM),
+						GEN_INT (MSTATUS_MIE_BIT)));
+      /* Save s1 back into mepc.  */
+      emit_insn (gen_riscv_csr_write (GEN_INT (MEPC_REGNUM),
+				      gen_rtx_REG (word_mode, S1_REGNUM)));
+      /* Save s0 back into mcause.  */
+      emit_insn (gen_riscv_csr_write (GEN_INT (MCAUSE_REGNUM),
+				      gen_rtx_REG (word_mode, S0_REGNUM)));
+
+      /* Restore S0 and S1.  */
+      riscv_save_restore_reg (word_mode, S1_REGNUM,
+			      step2 - (2 * UNITS_PER_WORD),
+			      riscv_restore_reg);
+      riscv_save_restore_reg (word_mode, S0_REGNUM,
+			      step2 - (1 * UNITS_PER_WORD),
+			      riscv_restore_reg);
+    }
 
   if (need_barrier_p)
     riscv_emit_stack_tie ();
@@ -4731,6 +4843,12 @@ riscv_expand_epilogue (int style)
       REG_NOTES (insn) = dwarf;
     }
 
+  /* Swap out the stack pointer from the mscratch register.  */
+  if (cfun->machine->interrupt_flags.sifive_clic_stack_swap_p)
+    emit_insn (gen_riscv_csr_read_write (stack_pointer_rtx,
+					 GEN_INT (MSCRATCHCSW_REGNUM),
+					 stack_pointer_rtx));
+
   if (use_restore_libcall)
     {
       rtx dwarf = riscv_adjust_libcall_cfi_epilogue ();
@@ -4750,7 +4868,8 @@ riscv_expand_epilogue (int style)
   /* Return from interrupt.  */
   if (cfun->machine->interrupt_handler_p)
     {
-      enum riscv_privilege_levels mode = cfun->machine->interrupt_mode;
+      enum riscv_privilege_levels mode
+	= cfun->machine->interrupt_flags.interrupt_mode;
 
       gcc_assert (mode != UNKNOWN_MODE);
 
@@ -5530,35 +5649,62 @@ riscv_function_ok_for_sibcall (tree decl ATTRIBUTE_UNUSED,
   return true;
 }
 
-/* Get the interrupt type, return UNKNOWN_MODE if it's not
+/* Get the intterupt type, return UNKNOWN_MODE if it's not
    interrupt function. */
-static enum riscv_privilege_levels
+static struct riscv_interrupt_flags
 riscv_get_interrupt_type (tree decl)
 {
+  struct riscv_interrupt_flags interrupt_flags;
+  bool interrupt_mode_set;
+ 
   gcc_assert (decl != NULL_TREE);
 
   if ((TREE_CODE(decl) != FUNCTION_DECL)
       || (!riscv_interrupt_type_p (TREE_TYPE (decl))))
-    return UNKNOWN_MODE;
+    {
+      interrupt_flags.interrupt_mode = UNKNOWN_MODE;
+      return interrupt_flags;
+    }
 
   tree attr_args
     = TREE_VALUE (lookup_attribute ("interrupt",
 				    TYPE_ATTRIBUTES (TREE_TYPE (decl))));
 
-  if (attr_args && TREE_CODE (TREE_VALUE (attr_args)) != VOID_TYPE)
+  /* Interrupt attributes are machine mode by default.  */
+  interrupt_flags.interrupt_mode = MACHINE_MODE;
+  interrupt_flags.sifive_clic_preemptible_p = FALSE;
+  interrupt_flags.sifive_clic_stack_swap_p = FALSE;
+  interrupt_mode_set = FALSE;
+
+  while (attr_args)
     {
       const char *string = TREE_STRING_POINTER (TREE_VALUE (attr_args));
 
-      if (!strcmp (string, "user"))
-	return USER_MODE;
-      else if (!strcmp (string, "supervisor"))
-	return SUPERVISOR_MODE;
-      else /* Must be "machine".  */
-	return MACHINE_MODE;
+      if (!strcmp (string, "SiFive-CLIC-preemptible"))
+	interrupt_flags.sifive_clic_preemptible_p = TRUE;
+      else if (!strcmp (string, "SiFive-CLIC-stack-swap"))
+	interrupt_flags.sifive_clic_stack_swap_p = TRUE;
+      else
+	{
+	  if (interrupt_mode_set)
+	    error ("%qs function cannot have two modes", "interrupt");
+	  interrupt_mode_set = TRUE;
+
+	  if (!strcmp (string, "user"))
+	    interrupt_flags.interrupt_mode = USER_MODE;
+	  else if (!strcmp (string, "supervisor"))
+	    interrupt_flags.interrupt_mode = SUPERVISOR_MODE;
+	  else if (!strcmp (string, "machine"))
+	    interrupt_flags.interrupt_mode = MACHINE_MODE;
+	  else
+	    /* Unreachable.  Checked in riscv_handle_type_attribute.  */
+	    abort ();
+	}
+
+      attr_args = TREE_CHAIN (attr_args);
     }
-  else
-    /* Interrupt attributes are machine mode by default.  */
-    return MACHINE_MODE;
+
+  return interrupt_flags;
 }
 
 /* Implement `TARGET_SET_CURRENT_FUNCTION'.  */
@@ -5592,31 +5738,43 @@ riscv_set_current_function (tree decl)
       if (args && TREE_CODE (TREE_VALUE (args)) != VOID_TYPE)
 	error ("%qs function cannot have arguments", "interrupt");
 
-      cfun->machine->interrupt_mode = riscv_get_interrupt_type (decl);
+      cfun->machine->interrupt_flags = riscv_get_interrupt_type (decl);
+
+      if (cfun->machine->interrupt_flags.interrupt_mode != MACHINE_MODE)
+	{
+	  if (cfun->machine->interrupt_flags.sifive_clic_preemptible_p)
+	    error ("SiFive CLIC preemptible %qs function must be machine mode",
+		   "interrupt");
+	  else if (cfun->machine->interrupt_flags.sifive_clic_stack_swap_p)
+	    error ("SiFive CLIC stack-swap %qs function must be machine mode",
+		   "interrupt");
+	}
 
-      gcc_assert (cfun->machine->interrupt_mode != UNKNOWN_MODE);
+      gcc_assert (cfun->machine->interrupt_flags.interrupt_mode
+		  != UNKNOWN_MODE);
     }
 
   /* Don't print the above diagnostics more than once.  */
   cfun->machine->attributes_checked_p = 1;
 }
 
-/* Implement TARGET_MERGE_DECL_ATTRIBUTES. */
+/* Implement TARGET_MERGE_DECL_ATTRIBUTES.  */
 static tree
 riscv_merge_decl_attributes (tree olddecl, tree newdecl)
 {
   tree combined_attrs;
 
-  enum riscv_privilege_levels old_interrupt_type
+  struct riscv_interrupt_flags old_interrupt_type
     = riscv_get_interrupt_type (olddecl);
-  enum riscv_privilege_levels new_interrupt_type
+  struct riscv_interrupt_flags new_interrupt_type
     = riscv_get_interrupt_type (newdecl);
 
-  /* Check old and new has same interrupt type. */
-  if ((old_interrupt_type != UNKNOWN_MODE)
-      && (new_interrupt_type != UNKNOWN_MODE)
-      && (old_interrupt_type != new_interrupt_type))
-    error ("%qs function cannot have different interrupt type", "interrupt");
+  /* Check old and new has same interrupt type.  */
+  if ((old_interrupt_type.interrupt_mode != UNKNOWN_MODE)
+      && (new_interrupt_type.interrupt_mode != UNKNOWN_MODE)
+      && (old_interrupt_type.interrupt_mode
+	  != new_interrupt_type.interrupt_mode))
+    error ("%qs function cannot have different interrupt type.", "interrupt");
 
   /* Create combined attributes.  */
   combined_attrs = merge_attributes (DECL_ATTRIBUTES (olddecl),
diff --git a/gcc/config/riscv/riscv.md b/gcc/config/riscv/riscv.md
index 834c641ad82..57901f4bd1e 100644
--- a/gcc/config/riscv/riscv.md
+++ b/gcc/config/riscv/riscv.md
@@ -141,6 +141,17 @@
   UNSPECV_FRFLAGS
   UNSPECV_FSFLAGS
 
+  ;; CSR read
+  UNSPECV_CSR_READ
+  ;; CSR read and set bits
+  UNSPECV_CSR_READ_SET_BITS
+  ;; CSR read and clear bits
+  UNSPECV_CSR_READ_CLEAR_BITS
+  ;; CSR read and write
+  UNSPECV_CSR_READ_WRITE
+  ;; CSR write
+  UNSPECV_CSR_WRITE
+
   ;; Interrupt handler instructions.
   UNSPECV_MRET
   UNSPECV_SRET
@@ -181,6 +192,13 @@
    (NORMAL_RETURN		0)
    (SIBCALL_RETURN		1)
    (EXCEPTION_RETURN		2)
+
+   (MSTATUS_REGNUM		0x300)
+   (MEPC_REGNUM			0x341)
+   (MCAUSE_REGNUM		0x342)
+   (MSCRATCHCSW_REGNUM		0x348)
+
+   (MSTATUS_MIE_BIT		8)
 ])
 
 (include "predicates.md")
@@ -2683,6 +2701,44 @@
   "TARGET_HARD_FLOAT"
   "fsflags\t%0")
 
+(define_insn "riscv_csr_read"
+  [(set (match_operand 0 "register_operand" "=r")
+	(unspec_volatile [(match_operand 1 "csr_address" "C")]
+			 UNSPECV_CSR_READ))]
+  ""
+  "csrr\t%0,%x1")
+
+(define_insn "riscv_csr_read_set_bits"
+  [(set (match_operand 0 "register_operand" "=r")
+	(unspec_volatile [(match_operand 1 "csr_address" "C")
+			  (match_operand 2 "csr_operand" "rK")]
+			 UNSPECV_CSR_READ_SET_BITS))]
+  ""
+  "csrrsi\t%0,%x1,%2")
+
+(define_insn "riscv_csr_read_clear_bits"
+  [(set (match_operand 0 "register_operand" "=r")
+	(unspec_volatile [(match_operand 1 "csr_address" "C")
+			  (match_operand 2 "csr_operand" "rK")]
+			 UNSPECV_CSR_READ_CLEAR_BITS))]
+  ""
+  "csrrci\t%0,%x1,%2")
+
+(define_insn "riscv_csr_read_write"
+  [(set (match_operand 0 "register_operand" "=r")
+	(unspec_volatile [(match_operand 1 "csr_address" "C")
+			  (match_operand 2 "csr_operand" "rK")]
+			 UNSPECV_CSR_READ_WRITE))]
+  ""
+  "csrrw\t%0,%x1,%2")
+
+(define_insn "riscv_csr_write"
+  [(unspec_volatile [(match_operand 0 "csr_address" "C")
+		     (match_operand 1 "register_operand" "r")]
+		    UNSPECV_CSR_WRITE)]
+  ""
+  "csrw\t%x0,%1")
+
 (define_insn "riscv_mret"
   [(return)
    (unspec_volatile [(const_int 0)] UNSPECV_MRET)]
diff --git a/gcc/doc/extend.texi b/gcc/doc/extend.texi
index 3743f66dc88..f86917d7654 100644
--- a/gcc/doc/extend.texi
+++ b/gcc/doc/extend.texi
@@ -5712,6 +5712,31 @@ void f (void) __attribute__ ((interrupt ("user")));
 Permissible values for this parameter are @code{user}, @code{supervisor},
 and @code{machine}.  If there is no parameter, then it defaults to
 @code{machine}.
+
+You can specify an SiFive CLIC preemptible interrupt handler by adding an
+optional parameter to the interrupt attribute like this:
+
+@smallexample
+void f (void) __attribute__ ((interrupt ("SiFive-CLIC-preemptible")));
+@end smallexample
+
+In this type of interrupt handler, in the prologue, the mepc and
+mcause registers are saved, and interrupts are enabled.  In the epilogue,
+interrupts are disabled, and the mepc and mcause registers are restored.
+This type of interrupt handler must be @code{machine} mode, and must
+not use the frame pointer.
+
+You can specify an SiFive CLIC stack swapping interrupt handler by adding an
+optional parameter to the interrupt attribute like this:
+
+@smallexample
+void f (void) __attribute__ ((interrupt ("SiFive-CLIC-stack-swap")));
+@end smallexample
+
+In this type of interrupt handler, the stack pointer will be swapped with
+the @code{mscratch} register in the prologue before the first use of the stack
+pointer, and in the epilogue after the last use of the stack pointer.  This
+type of interrupt handler must be @code{machine} mode.
 @end table
 
 @node RL78 Function Attributes
diff --git a/gcc/doc/md.texi b/gcc/doc/md.texi
index 2c67c818da5..d5b08f77e9a 100644
--- a/gcc/doc/md.texi
+++ b/gcc/doc/md.texi
@@ -3525,6 +3525,9 @@ Integer zero.
 @item K
 A 5-bit unsigned immediate for CSR access instructions.
 
+@item C
+A 12-bit unsigned immediate for CSR register address.
+
 @item A
 An address that is held in a general-purpose register.
 
diff --git a/gcc/testsuite/gcc.target/riscv/interrupt-5.c b/gcc/testsuite/gcc.target/riscv/interrupt-5.c
index 324954eb1dd..03d8173e5b3 100644
--- a/gcc/testsuite/gcc.target/riscv/interrupt-5.c
+++ b/gcc/testsuite/gcc.target/riscv/interrupt-5.c
@@ -19,3 +19,18 @@ void __attribute__ ((interrupt ("hypervisor")))
 sub3 (void)
 { /* { dg-warning "argument to" } */
 }
+
+void __attribute__ ((interrupt ("user", "machine")))
+sub4 (void)
+{ /* { dg-error "cannot have two modes" } */
+}
+
+void __attribute__ ((interrupt ("user", "SiFive-CLIC-preemptible")))
+sub5 (void)
+{ /* { dg-error "must be machine mode" } */
+}
+
+void __attribute__ ((interrupt ("user", "SiFive-CLIC-stack-swap")))
+sub6 (void)
+{ /* { dg-error "must be machine mode" } */
+}
diff --git a/gcc/testsuite/gcc.target/riscv/interrupt-conflict-mode.c b/gcc/testsuite/gcc.target/riscv/interrupt-conflict-mode.c
index e9f145265c0..793397feaf4 100644
--- a/gcc/testsuite/gcc.target/riscv/interrupt-conflict-mode.c
+++ b/gcc/testsuite/gcc.target/riscv/interrupt-conflict-mode.c
@@ -6,5 +6,5 @@ foo(void);
 
 void __attribute__ ((interrupt ("machine")))
 foo (void)
-{ /* { dg-error "function cannot have different interrupt type" } */
+{ /* { dg-error "function cannot have different interrupt type." } */
 }
diff --git a/gcc/testsuite/gcc.target/riscv/preemptible-1.c b/gcc/testsuite/gcc.target/riscv/preemptible-1.c
new file mode 100644
index 00000000000..578667f46cd
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/preemptible-1.c
@@ -0,0 +1,11 @@
+/* Verify that csr instructions emitted.  */
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+extern int interrupt_count;
+
+void __attribute__ ((interrupt ("SiFive-CLIC-preemptible")))
+sub (void)
+{
+  interrupt_count++;
+}
+/* { dg-final { scan-assembler-times "csr" 6 } } */
diff --git a/gcc/testsuite/gcc.target/riscv/preemptible-2.c b/gcc/testsuite/gcc.target/riscv/preemptible-2.c
new file mode 100644
index 00000000000..27cd31de188
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/preemptible-2.c
@@ -0,0 +1,11 @@
+/* Verify that all temp regs saved for call.  */
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+extern int vector_10 (void);
+
+void __attribute__ ((interrupt ("SiFive-CLIC-preemptible")))
+sub (void)
+{
+  vector_10 ();
+}
+/* { dg-final { scan-assembler-times "s\[wd\]\t\[at\]\[0-7\]" 15 } } */
diff --git a/gcc/testsuite/gcc.target/riscv/preemptible-3.c b/gcc/testsuite/gcc.target/riscv/preemptible-3.c
new file mode 100644
index 00000000000..c01d9ded7d5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/preemptible-3.c
@@ -0,0 +1,9 @@
+/* Verify that csr instructions are not emitted.  */
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+void __attribute__ ((interrupt ("SiFive-CLIC-preemptible")))
+sub (void)
+{
+}
+/* { dg-final { scan-assembler-not "csr" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/stack-swap-1.c b/gcc/testsuite/gcc.target/riscv/stack-swap-1.c
new file mode 100644
index 00000000000..bbc89b58e18
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/stack-swap-1.c
@@ -0,0 +1,17 @@
+/* Verify that stack swapping instructions are emitted.  */
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+void __attribute__ ((interrupt ("SiFive-CLIC-stack-swap")))
+foo2 (void)
+{
+  extern volatile int INTERRUPT_FLAG;
+  INTERRUPT_FLAG = 0;
+
+  extern volatile int COUNTER;
+#ifdef __riscv_atomic
+  __atomic_fetch_add (&COUNTER, 1, __ATOMIC_RELAXED);
+#else
+  COUNTER++;
+#endif
+}
+/* { dg-final { scan-assembler-times "mscratchcsw" 2 } } */
-- 
2.25.1

